"""
coulombwaves
============

Basic Coulomb wave operations are provided. These are:

	1) construct Coulomb waves
	2) store to disk
	3) load from disk
	4) nice representation of Coulomb waves

"""
import sys
import os, errno
import tables
from numpy import array, where, r_, sqrt, zeros, array, abs, dot, conj, pi, \
	double, complex
import pyprop
from einpartikkel.eigenvalues.eigenvalues import SetupRadialEigenstates
from einpartikkel.utils import RegisterAll
from namegenerator import GetRadialPostfix, GetAngularPostfix
from above import SetRadialCoulombWave

@RegisterAll
class CoulombWaves(object):
	"""
	"""
	_DataItemAttrName = "DataItems"
	_MetaDataItemAttrName = "MetaDataItems"
	
	def __init__(self, conf, Z, Emax, dE):
		"""Return a Coulomb wave object
		"""
		#Config object.
		self.Config = conf

		self.Z = Z
		self.MaxEnergy = Emax
		self.EnergyResolution = dE

		#Data structure for Coulomb waves etc
		self._Data = {}
		self._MetaData = {}

		md = self._MetaData
		md["Z"] = self.Z
		md["Emax"] = self.MaxEnergy
		md["dE"] = self.EnergyResolution

		#Generate file name.
		self.FolderName = "CoulombWaves" #TODO: this should be generated somehow
		self.FileName = CoulombWaveNameGenerator(self.Config, self.FolderName,\
				self.Z)

		self._SetupComplete = False
	

	def SetData(self, data):
		self._Data = data
		self._SetupComplete = True


	@classmethod
	def FromFile(cls, filename):
		"""Setup CoulombWaves object from serialized (file) data
		"""
		d = {}
		metaDataItems = {}
		with tables.openFile(filename, "r") as f:
			#Load data
			dataItemNames = f.getNodeAttr("/", cls._DataItemAttrName)
			for dataItem in dataItemNames:
				d[dataItem] = f.getNode("/", dataItem)[:]

			#Load metadata
			metaDataItemNames = f.getNodeAttr("/", cls._MetaDataItemAttrName)
			for mdItem in metaDataItemNames:
				metaDataItems[mdItem] = f.getNodeAttr("/", mdItem)
			
		#Load config object.
		config = pyprop.LoadConfigFromFile(filename, "/")
		
		obj = cls(config, **metaDataItems)
		#obj._Data = d
		#obj._SetupComplete = True
		obj.SetData(d)

		return obj


	def Setup(self):
		"""Calculate the Coulomb waves specified by config object
		
		"""
		
		#Check if we have already calculated coulomb waves
		if self._SetupComplete:
			return

		d = self._Data

		#Retrieve list of angular momenta (l)
		d["AngularMomenta"] = [it.l for it in self.Config.AngularRepresentation.index_iterator]

		#Create wavefunction
		self.Psi = pyprop.CreateWavefunction(self.Config)
		
		#Calculate eigenstates
		E, cw = SetupRadialCoulombStatesEnergyNormalized(self.Psi, self.Z, \
			self.MaxEnergy, self.EnergyResolution)

		d["Energies"] = E
		d["CoulombWaves"] = cw

		self._SetupComplete = True
    
    
	def Serialize(self):
		"""Store Coulomb waves on disk

		Store Coulomb waves in a HDF5 file with autogenerated name

		"""
		assert (self._SetupComplete)

		#Check that folder(s) exists, make them if not
		filePath = os.path.dirname(self.FileName)
		if not os.path.exists(filePath):
			os.makedirs(filePath)
			try:
				os.makedirs(filePath)
			except OSError as exc:
				if exc.errno == errno.EEXIST:
					pass
				else:
					raise

		with tables.openFile(self.FileName, "w") as f:
			#Store Coulomb wave data
			for dataItemName, dataItemValue in self._Data.iteritems():
				f.createArray("/", "%s" % dataItemName, dataItemValue)

			#Store metadata
			for dataItemName, dataItemValue in self._MetaData.iteritems():
				f.setNodeAttr("/", dataItemName, dataItemValue)
			
			#Store data item names
			f.setNodeAttr("/", self._DataItemAttrName, self._Data.keys())
			f.setNodeAttr("/", self._MetaDataItemAttrName, self._MetaData.keys())

		#Saving config object.
		pyprop.serialization.SaveConfigObject(self.FileName, "/", self.Config)


	def IterateStates(self, threshold):
		"""
		IterateStates(self, threshold)
		
		Iterate over all states with energies over threshold.

		Parametres
		----------
		threshold : (float) lower energy cutoff

		"""
		assert (self._SetupComplete)
		enList = self._Data["Energies"]
		cwList = self._Data["CoulombWaves"]
		#for curL, (E, curCW) in enumerate(zip(enList, cwList)):
		idxIt = self.Config.AngularRepresentation.index_iterator
		for angIdx, lmIdx in enumerate(idxIt):
			#Get current l and m
			l = lmIdx.l
			m = lmIdx.m
			
			#Get energies and Coulomb waves
			curE = array(enList[l])
			curCW = array(cwList[l])

			#Filter out unwanted energies.
			idx = where(curE > threshold)
			filteredE = curE[idx]
			filteredCW = curCW[:,idx]
			yield angIdx, filteredE, filteredCW, l, m


def CoulombWaveNameGenerator(conf, folderName, Z):
	"""
	fileName = CoulombWaveNameGenerator(conf, folderName)

	Returns a generated file name.

	Returns
	-------
	fileName : (string) generated file name.

	"""

	#Coulomb wave characteristics
	radialPostfix = "_".join(GetRadialPostfix(conf))
	angularPostfix = "_".join(GetAngularPostfix(conf))
	chargePostfix = "Z%s" % Z
	
	filename = folderName + "/" 
	filename += "_".join([radialPostfix, angularPostfix, \
		chargePostfix])
	filename += ".h5"
	
	return filename


#---------------------------------------------------------------------------------------
#            Coulomb Wave Analysis
#---------------------------------------------------------------------------------------
#def SetupRadialBesselStatesEnergyNormalized(prop, Z, Emax, dE):
#	E = r_[dE:Emax:dE]
#	k = sqrt(E*2)
#
#	psi = prop.psi
#	bspline = psi.GetRepresentation().GetRepresentation(1).GetBSplineObject()
#	l = array(psi.GetRepresentation().GetGlobalGrid(0), dtype=int)
#
#	
#	#Setup Radial Waves
#	S = SetupOverlapMatrix(prop)
#	coulWaves = map(lambda curL: array(map(lambda curK: sqrt(2*dE/pi/curK)*GetRadialBesselWaveBSplines(Z, int(curL), curK, bspline, S), k)).transpose(), l)
#	energies = [E]*len(l)
#
#	return energies, coulWaves
#
#
#def SetupRadialCoulombStatesMomentumNormalized(psi, Z, kmax, dk):
#	k = r_[dk:kmax:dk]
#	E = k**2 / 2
#
#	bspline = psi.GetRepresentation().GetRepresentation(1).GetBSplineObject()
#	l = array(psi.GetRepresentation().GetGlobalGrid(0), dtype=int)
#	
#	#Setup Radial Waves
#	coulWaves = map(lambda curL: array(map(lambda curK: sqrt(2*dk/pi)*GetRadialCoulombWaveBSplines(Z, int(curL), curK, bspline), k)).transpose(), l)
#	energies = [E]*len(l)
#
#	return energies, coulWaves


def SetupRadialCoulombStatesEnergyNormalized(psi, Z, Emax, dE):
	"""Calculate radial Coulomb states with energy normalization

	Input
	-----
	psi: (wavefunction) a wavefunction with the desired representation
	Z: (int) the Coulomb charge
	Emax: (double) desired max energy of Coulomb waves
	dE: (double) energy resolution

	"""

	logger = pyprop.GetFunctionLogger()
	E = r_[dE:Emax:dE]
	k = sqrt(E*2)
	
	bspline = psi.GetRepresentation().GetRepresentation(1).GetBSplineObject()
	l = array(psi.GetRepresentation().GetGlobalGrid(0), dtype=int)
	
	#Setup Radial Waves
	def calculateForL(curL):
		logger.info("Generating Coulomb waves for Z = %s, l = %s..." % (Z, curL))
		result = \
			array(map(lambda curK: sqrt(2*dE/pi/curK)*GetRadialCoulombWaveBSplines(Z, int(curL), curK, bspline), k))
		return result.transpose()

	#coulWaves = map(lambda curL: array(map(lambda curK: sqrt(2*dE/pi/curK)*GetRadialCoulombWaveBSplines(Z, int(curL), curK, bspline), k)).transpose(), l)
	coulWaves = map(calculateForL, l)
	energies = [E]*len(l)

	return energies, coulWaves


def GetRadialCoulombWave(Z, l, k, rmax=100):
	#Get the Coulomb function in grid space
	dr = 0.01
	r = r_[dr:rmax:dr]
	wav = zeros(len(r), dtype=double)
	SetRadialCoulombWave(Z, l, k, r, wav)

	return r, wav	


def GetRadialCoulombWaveBSplines(Z, l, k, bsplineObj):
	#Get the Coulomb function in grid space
	r = bsplineObj.GetQuadratureGridGlobal()
	wav = zeros(len(r), dtype=double)
	SetRadialCoulombWave(Z, l, k, r, wav)
	cplxWav = array(wav, dtype=complex)

	#get bspline coeffs
	coeff = zeros(bsplineObj.NumberOfBSplines, dtype=complex)
	bsplineObj.ExpandFunctionInBSplines(cplxWav, coeff)

	return coeff

def GetRadialBesselWaveBSplines(Z, l, k, bsplineObj, S):
	besselFunc = lambda k, r: sin(k*r + Z/k * log(k*r) - l*pi/2 + GetCoulombPhase(l, Z / k))

	#Get the Coulomb function in grid space
	r = bsplineObj.GetQuadratureGridGlobal()
	wav = array(besselFunc(k, r), dtype=complex)

	#get bspline coeffs
	coeff = zeros(bsplineObj.NumberOfBSplines, dtype=complex)
	bsplineObj.ExpandFunctionInBSplines(wav, coeff)

	return coeff


def CalculateDpDk(Z, k, psi, S):
	bspline = psi.GetRepresentation().GetRepresentation(1).GetBSplineObject()
	l = array(psi.GetRepresentation().GetGlobalGrid(0), dtype=int)
	
	#Setup Radial Waves
	coulWaves = map(lambda curL: map(lambda curK: GetRadialCoulombWaveBSplines(Z, int(curL), curK, bspline, S), k), l)

	#calculate dpdk
	dpdk = zeros(len(k), dtype=double)
	for lIdx, (curL, wavList) in enumerate(zip(l, coulWaves)):
		for kIdx, (curK, wav) in enumerate(zip(k, wavList)):
			dpdk[kIdx] += abs(dot(conj(wav), dot(S, psi.GetData()[lIdx, :])))**2

	return dpdk

def GetCoulombPhase(l, eta):
	sigma = gamma(l + 1 + eta * 1j)
	return arctan2(sigma.imag, sigma.real)

